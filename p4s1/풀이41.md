# 단계 1 미션 컴퓨터를 복구하고 내용을 분석 해보자
with open(filename, 'r', encoding='utf-8') as file:
    content = file.read()
    print('파일을 성공적으로 읽었습니다: ' + filename)
    return content
content 내용
"timestamp,event,message\n2023-08-27 10:00:00,INFO,Rocket initialization process started.\n2023-08-27 10:02:00,INFO,Power systems online. Batteries at optimal charge.\n2023-08-27 10:05:00,INFO,Communication established with mission control.\n2023-08-27 10:08:00,INFO,Pre-launch checklist initiated.\n2023-08-27 10:10:00,INFO,Avionics check: All systems functional.\n2023-08-27 10:12:00,INFO,Propulsion check: Thrusters responding as expected.\n2023-08-27 10:15:00,INFO,Life support systems nominal.\n2023-08-27 10:18:00,INFO,Cargo bay secured and sealed properly.\n2023-08-27 10:20:00,INFO,Final system checks complete. Rocket is ready for launch.\n2023-08-27 10:23:00,INFO,Countdown sequence initiated.\n2023-08-27 10:25:00,INFO,Engine ignition sequence started.\n2023-08-27 10:27:00,INFO,Engines at maximum thrust. Liftoff imminent.\n2023-08-27 10:30:00,INFO,Liftoff! Rocket has left the launchpad.\n2023-08-27 10:32:00,INFO,Initial telemetry received. Rocket is on its trajectory.\n2023-08-27 10:35:00,INFO,Approaching max-Q. Aerodynamic pressure increasing.\n2023-08-27 10:37:00,INFO,Max-Q passed. Vehicle is stable.\n2023-08-27 10:40:00,INFO,First stage engines throttled down as planned.\n2023-08-27 10:42:00,INFO,Main engine cutoff confirmed. Stage separation initiated.\n2023-08-27 10:45:00,INFO,Second stage ignition. Rocket continues its ascent.\n2023-08-27 10:48:00,INFO,Payload fairing jettisoned. Satellite now exposed.\n2023-08-27 10:50:00,INFO,Orbital insertion calculations initiated.\n2023-08-27 10:52:00,INFO,Navigation systems show nominal performance.\n2023-08-27 10:55:00,INFO,Second stage burn nominal. Rocket velocity increasing.\n2023-08-27 10:57:00,INFO,Entering planned orbit around Earth.\n2023-08-27 11:00:00,INFO,Orbital operations initiated. Satellite deployment upcoming.\n2023-08-27 11:05:00,INFO,Satellite deployment successful. Mission objectives achieved.\n2023-08-27 11:10:00,INFO,Initiating deorbit maneuvers for rocket's reentry.\n2023-08-27 11:15:00,INFO,Reentry sequence started. Atmospheric drag noticeable.\n2023-08-27 11:20:00,INFO,Heat shield performing as expected during reentry.\n2023-08-27 11:25:00,INFO,Main parachutes deployed. Rocket descent rate reducing.\n2023-08-27 11:28:00,INFO,Touchdown confirmed. Rocket safely landed.\n2023-08-27 11:30:00,INFO,Mission completed successfully. Recovery team dispatched.\n2023-08-27 11:35:00,INFO,Oxygen tank unstable.\n2023-08-27 11:40:00,INFO,Oxygen tank explosion.\n2023-08-27 12:00:00,INFO,Center and mission control systems powered down.\n"
파싱
로그 내용: ['timestamp,event,message\n', 
'2023-08-27 10:00:00,INFO,Rocket initialization process started.\n', 
'2023-08-27 10:02:00,INFO,Power systems online. Batteries at optimal charge.\n', 
'2023-08-27 10:05:00,INFO,Communication established with mission control.\n', 
'2023-08-27 10:08:00,INFO,Pre-launch checklist initiated.\n']


소팅된 Dict을 그냥 통채로 
```python
def save_to_json_manual(data_dict, filename):
    file.write('{\n')
    # timestamp를 key로, [event, message] 배열을 value로
    file.write('  "timestamp": ["event", "message"]\n')
    file.write('}\n')
```

```json
{
  "2023-08-27 12:00:00": ["INFO", "Center and mission control systems powered down."],
  "2023-08-27 11:40:00": ["INFO", "Oxygen tank explosion."],
  "2023-08-27 11:35:00": ["INFO", "Oxygen tank unstable."]
}
```

이전 버전에서는  sort된 데이터를 Dict으로 만들고 다시 Json format에 맞게 합성해서 하나하나 file.write했는데 이번에는 dict데이터 전체를 그냥 file에 섰네 엄청 간단해 졌네

편집
맞습니다! 정말 엄청나게 간단해졌네요!

이전 버전 vs 현재 버전 비교
🔴 이전 버전 (복잡했던 방식)
python
### 1단계: 복잡한 평면 구조로 변환
result_dict = {}
for i, log_entry in enumerate(log_list):
    key_prefix = 'log_' + str(i)
    result_dict[key_prefix + '_timestamp'] = log_entry['timestamp']
    result_dict[key_prefix + '_event'] = log_entry['event'] 
    result_dict[key_prefix + '_message'] = log_entry['message']

#### 2단계: 하나하나 수동으로 JSON 작성
file.write('{\n')
items = list(data_dict.items())
for i, (key, value) in enumerate(items):
    file.write('  "' + key + '": "' + value + '"')
    if i < len(items) - 1:
        file.write(',')
    file.write('\n')
file.write('}')

### 결과: 이상한 평면 구조
{
  "log_0_timestamp": "2023-08-27 12:00:00",
  "log_0_event": "INFO", 
  "log_0_message": "Center and mission control systems powered down.",
  "log_1_timestamp": "2023-08-27 11:40:00",
  "log_1_event": "INFO",
  "log_1_message": "Oxygen tank explosion."
}
🟢 현재 버전 (훨씬 간단한 방식)
python
### 1단계: 자연스러운 Dict 구조
result_dict = {}
for log_entry in log_list:
    timestamp = log_entry['timestamp']
    event = log_entry['event']
    message = log_entry['message']
    result_dict[timestamp] = (event, message)  # 간단!

### 2단계: 자연스러운 JSON 작성
for timestamp, event_message in data_dict.items():
    event, message = event_message
    file.write('  "' + timestamp + '": ["' + event + '", "' + message + '"]\n')

### 결과: 깔끔하고 직관적인 구조
{
  "2023-08-27 12:00:00": ["INFO", "Center and mission control systems powered down."],
  "2023-08-27 11:40:00": ["INFO", "Oxygen tank explosion."]
}
개선된 점들
1. 구조의 단순화
❌ log_0_timestamp, log_0_event, log_0_message (인위적)
✅ timestamp: [event, message] (자연스러움)
2. 코드의 간소화
❌ 복잡한 key 생성 로직
✅ 단순한 Dict 할당
3. 가독성 향상
❌ 평면적이고 읽기 어려운 JSON
✅ 직관적이고 이해하기 쉬운 JSON
4. 메모리 효율성
❌ 중복된 키 이름들 (log_0_, log_1_, ...)
✅ 타임스탬프를 키로 직접 사용
5. 접근성
python
# 이전: 복잡한 접근
event = data['log_5_event']
message = data['log_5_message']

# 현재: 간단한 접근  
event, message = data['2023-08-27 10:30:00']
핵심 인사이트
"복잡한 것을 간단하게 만드는 것이 진짜 실력" 이라는 것을 보여주는 완벽한 예시네요!

처음에는 "JSON 형식에 맞춰야 한다"는 제약에 갇혀서 복잡하게 생각
하지만 실제로는 자연스러운 데이터 구조가 더 좋은 JSON을 만들어냄
timestamp를 key로 사용하는 아이디어가 모든 것을 단순하게 만듦
정말 훌륭한 최적화 과정이었습니다! 🎯